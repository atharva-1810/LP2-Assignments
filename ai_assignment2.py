# -*- coding: utf-8 -*-
"""AI_assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LZZ1yU0xQ9qkqg-r9Mstq-1BuP0g-FIH
"""

from queue import PriorityQueue

class PuzzleNode:
    def __init__(self, state, parent=None, action=None, cost=0, heuristic=0):
        self.state = state
        self.parent = parent
        self.action = action
        self.cost = cost
        self.heuristic = heuristic

    def __lt__(self, other):
        return (self.cost + self.heuristic) < (other.cost + other.heuristic)

    def __eq__(self, other):
        return self.state == other.state

def manhattan_distance(state, goal_state):
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                row, col = divmod(state[i][j]-1, 3)
                distance += abs(row - i) + abs(col - j)
    return distance

def get_possible_moves(state):
    moves = []
    zero_row, zero_col = None, None
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                zero_row, zero_col = i, j
                break
    deltas = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for dr, dc in deltas:
        new_row, new_col = zero_row + dr, zero_col + dc
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_state = [row[:] for row in state]
            new_state[zero_row][zero_col] = new_state[new_row][new_col]
            new_state[new_row][new_col] = 0
            moves.append(new_state)
    return moves

def is_goal_state(state, goal_state):
    return state == goal_state

def reconstruct_path(node):
    path = []
    while node is not None:
        path.append((node.state, node.action))
        node = node.parent
    return path[::-1]

def astar(initial_state, goal_state):
    open_set = PriorityQueue()
    start_node = PuzzleNode(initial_state, None, None, 0, manhattan_distance(initial_state, goal_state))
    open_set.put(start_node)

    while not open_set.empty():
        current_node = open_set.get()

        if is_goal_state(current_node.state, goal_state):
            return reconstruct_path(current_node)

        for move in get_possible_moves(current_node.state):
            new_cost = current_node.cost + 1
            new_heuristic = manhattan_distance(move, goal_state)
            new_node = PuzzleNode(move, current_node, move, new_cost, new_heuristic)
            open_set.put(new_node)

    return None

# Example usage:
initial_state = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]

goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

path = astar(initial_state, goal_state)
if path:
    print("Solution found!")
    for state, action in path:
        print("Action:", action)
        for row in state:
            print(row)
        print()
else:
    print("No solution found.")